<img width="1895" height="1034" alt="image" src="https://github.com/user-attachments/assets/37af3764-8fa4-410b-a5fc-154923c6fb7c" />


# 자체 엔진 프로젝트 : The Devils Summoner

실행환경 : 86x, (Debug/Release)

게임영상 : https://youtu.be/1XLVDzrFyE4

## 1. 프로젝트 개요
'The Devils Summoner'는 자체 제작한 C++ DirectX 11 기반 게임 엔진을 사용하여 개발한 1인칭 3D FPS 게임입니다.  이 프로젝트에서 저는 그래픽스를 제외한 엔진의 핵심 기능들을 직접 설계하고 구현하며, 실제 게임을 제작하는 과정을 통해 엔진의 구조를 확립하는 것을 목표로 진행하였습니다.

## 2. 기술 설명
 ### 2.1 엔진 아키텍처 및 업데이트 파이프라인
엔진의 핵심은 매니저(Manager) 시스템과 컴포넌트(Component) 기반 설계에 있습니다. 전체 업데이트 흐름은 
GameProcess → GameEngine → SceneManager → Scene → GameObject → Component 순서로 명확한 계층 구조를 가집니다. Scene이 활성화되면, 해당 씬에 속한 모든 GameObject들을 순회하며 각 객체가 소유한 Component들의 업데이트 함수를 호출하는 방식으로 동작합니다. 이 구조를 통해 게임의 각 요소가 독립적으로 작동하면서도 전체적으로는 유기적으로 연결되도록 설계했습니다.

 ### 2.2 컴포넌트 기반 설계 (Component-Based Design)
게임 세상에 존재하는 모든 객체(GameObject)는 기능별로 독립된 부품, 즉 컴포넌트의 조합으로 이루어집니다. 모든 컴포넌트는 Component라는 공통 인터페이스를 상속받으며, Update, Render 등 게임 루프와 연동되는 가상 함수들을 가집니다. 예를 들어, 객체의 위치와 회전을 담당하는 Transform, 3D 모델을 화면에 그리는 MeshRenderer, 플레이어의 조작을 처리하는 PlayerController 등 다양한 컴포넌트를 GameObject에 부착하여 원하는 기능을 구현할 수 있습니다. 이 방식은 코드의 재사용성을 높이고 객체의 기능을 유연하게 확장할 수 있게 합니다.

### 2.3 리소스 관리 시스템 (Resource Management System)
사운드, 3D 모델(FBX), 이미지 등 다양한 종류의 게임 리소스를 효율적으로 관리하기 위해 리소스 매니저를 구현했습니다. 이 시스템의 핵심은 템플릿(Template)과 빌더(Builder) 패턴의 활용입니다.
 * 템플릿 기반 로딩: LoadResource<T>() 템플릿 함수를 통해 어떤 타입의 리소스든 일관된 방식으로 로드할 수 있습니다.
 * 빌더 패턴: 각 리소스 타입(FBX, Bitmap, Audio 등)에 맞는 빌더 클래스를 만들어 리소스 생성 과정을 캡슐화했습니다. 이 덕분에 새로운 리소스 타입이 추가되더라도 리소스 매니저의 코드를 수정할 필요 없이 새로운 빌더만 추가하면 되어 확장성이 뛰어납니다.
 * 추상화 및 관리: 로드된 모든 리소스는 IResource라는 공통 인터페이스를 통해 추상화되며, map 자료구조에 저장되어 중복 로드를 방지하고 빠르게 접근할 수 있도록 했습니다.

 ### 2.4 상호작용 가능한 UI 시스템
게임의 UI, 특히 버튼(Button) 컴포넌트는 사용자와의 상호작용을 유연하게 처리할 수 있도록 설계했습니다. 버튼은 마우스의 위치를 실시간으로 추적하여 Normal (일반), Hover (마우스 올림), Pressed (누르는 중) 상태를 감지합니다. 가장 큰 특징은 각 상태 변화에 따른 이벤트 처리를 람다(lambda) 함수로 외부에서 주입할 수 있다는 점입니다. SetOnClick(), SetOnHover() 등의 함수를 통해 버튼이 클릭되거나 마우스가 올라왔을 때 실행될 코드를 게임 로직 단에서 간편하게 정의할 수 있어 UI와 로직의 결합도를 낮추고 코드의 가독성을 높였습니다.

 ### 2.5 3D Transform 및 FPS 컨트롤러
 * Transform 컴포넌트: 모든 게임 오브젝트의 3D 공간 내 위치, 회전, 크기를 관리합니다. 
 * FPS 컨트롤러: PlayerController 컴포넌트를 통해 1인칭 시점의 게임 플레이를 구현했습니다. 마우스 움직임에 따라 카메라 시점이 회전하고, 키보드 입력으로 캐릭터가 이동하는 기능을 개발했습니다. 카메라의 회전 각도를 제한하여 비정상적인 움직임을 방지하는 디테일도 추가했습니다.


2.6 FSM (상태 기계) 구현
적 AI와 같이 복잡한 행동 패턴을 관리하기 위해 **FSM(Finite State Machine, 유한 상태 기계)**을 직접 구현했습니다. BaseState 인터페이스를 상속받는 각각의 상태(예: 대기, 추격, 공격) 클래스를 만들고, FSM이 현재 상태에 따라 적절한 로직을 실행하고 조건에 따라 다른 상태로 전환하도록 설계했습니다. 이를 통해 AI의 행동 로직을 체계적으로 관리할 수 있었습니다.

2.7 CRTP 싱글턴 패턴 (CRTP Singleton Pattern)
엔진 전역에서 단 하나만 존재해야 하는 관리자 클래스들을 위해 **CRTP(Curiously Recurring Template Pattern)**를 이용한 싱글턴 패턴을 도입했습니다. 템플릿으로 만들어진 SingleTon 클래스를 상속받기만 하면 어떤 클래스든 손쉽게 싱글턴으로 만들 수 있어, 코드 중복을 줄이고 일관된 방식으로 싱글턴 객체를 관리할 수 있게 했습니다.
