[Engine여행]
오후 2:13 2023-12-16
뭐 어떻게 해보자! 

오후 3:23 2023-12-16
엔진에 영상이 올라갈 수 있으면 재밌겠다.


<<<<<<< .mine
+ 메모리누수검사를 추가하자

오후 4:08 2023-12-20



[프로그램을 실행한다.]

1. 초기화
2. Update & Render
/-------------- Loop ------------------/
	[[게임이 돌아간다]]
	1) Scene생성
	2) Update & Render

	//-------------- Loop ------------------//
	//--------------------------------------//
		(1) 오브젝트 생성
		(2) Update & Render
		(3) 씬 종료
	//--------------------------------------//	
	//--------------------------------------//	

	3) Scene 삭제 || 보관
/--------------------------------------/
3. 게임종료



1. Entity는 컴포넌트를 저장한다.
2. 컴포넌트는 IComponent를 상속받아 각각의 기능을 담당한다.


3. Scene은 현재 게임에 사용되는 오브젝트들을 저장한다.
4. 오브젝트들은 Entity다
5. 

-------------------------------------------------------
1. Scene 매니저를 만든다.
+ Scene을 만든다.

2. Object 매니저를 만든다
+ 오브젝트를 만든다. 


----------------------------------
|| Scnene			||
||	ㄴ Object(Entity)	||
||		ㄴ Component	||
----------------------------------

1. Scene을 만든다.
	-> Scene은 Scene매니저에서 생성한다.
2. Object를 만든다.
3. Component를 만든다.



------------------------------------
player : hp, ulf....  

object << component 

player
- hp
- mp

오브젝트를 만든다 -> SceneInit
이 시점에 컴포넌트들을 생성하고
오브젝트에 붙인다.! 


오후 8:27 2023-12-26

리소스 매니저는 Scene이 갖고 사용해야한다
그러면 
engine -> SceneManager -> Scene까지 가야함


오후 1:40 2023-12-27


1. 컴포넌트를 생성하고 저장하는 부분을 
Gameobj로 옮기자 -> (현재 objManager에 잇다)

2. 화면에 올라오는 내용을 obj단위로 분리하자

3. 분리된 obj들을 component단위로 분리하자

4. obj에 붙어있는 component 들을
사용하는 component를 만들자

5. Scene을 상속받는 실제 사용되는 Scene을 만들자

6. 너무 많은 매개변수를 구조체로 한 번에 넘겨주자



----------------------------------

오브젝트 1
-> 그림을 그린다.
	<BackGround>
	- 1) 위치, 크기, 리소스를 갖고 있는다.
	- 2) 리소스를 갖고 있는다.

	<Render>
	- 1) 위치, 크기, 리소스를 바탕으로 그린다
오브젝트 2
-> Text를 출력한다. 
	<printer>를 기본으로 하자


----------------------------------
Time을 어떻게 사용할지 결정해야한다.
-> 타임매니저 포인터를 받기로함

---------------------------------
이니셜라이즈를  컴포넌트에 갖다 박는다
DrawSet이 무분별하게 복사되는중, 해결해야한다
컴포넌트들이 너무 일회성이다.

-----------------------------------
오후 4:06 2023-12-29
이제 엔진은 컴포넌트 단위로 (간신히)돌아가고 있다.
마구잡이로 만들어서 많은 문제가 남아있는데 어떻게 해결할까? 

[문제점]

8. 리소스매니저의 인터페이스를 만들자
	L 비트맵을 뽑기위해서 만들었던 리소스매니저의 인자들이 
	wstring과 Hbitmap인데 모든 리소스에 범용적으로 사용할 수 없다
	특히 GetResource는 하나의 리소스를 반환하면 IResource매니저 자체가
	의미없이 작동한다.
	1) Resource라는 객체을 만들어서 리턴한다.
		ㄴ 자료형이 추가될때마다 Resource 클래스를 손봐야한다.
	2) 템플릿으로 만든다.
		-> 함수만? 혹은 클래스 전체를? 
		-> 인터페이스로 만들고 또 템플릿을????? 
			ㄴ인터페이스에는 템플릿을 넣을 수 없다

10. 리소스매니저의 unorderdmap의 데이터를 어떻게 지우지? 


1. 인자들이 너무 더럽게 전달된다.
	ㄴ 매개변수가 너무길다.
	ㄴ 무분별하게 '복사' 된다

9. Define을 어디에 어떻게 넣어야 할까? 
	헤더를 만들어서 추가해야 하나? 
	ㄴ define과 헤더에 넣고 쓰기 차이를 모르겠다.
	ㄴ getcomponent<>() 로 사용하기에 너무길다.


2. 너무 많은 누수..! 
	ㄴ스마트 포인터로 바꾸면 되지 않을까? 
	ㄴ 혹은 제대로 할당을 해제해주는 구간이 필요하다

3. 컴포넌트들이 너무 일회성이다.
	ㄴ 재사용가능하게 만들려면 어떤걸 고려하고 어떻게해야지? 

4. input매니저를 배껴온거라서 사실 사용법 이해가 안됨

5. component들의 '초기화' 부분이 없다
	ㄴ 언제 하지? 

6. audio 는 컴포넌트화 시키지 못했다.

7. 모든 컴포넌트가 Update와 Render를 필요로 하진 않는다.
	ㄴ 하지만 모두 갖고 있어; 좋지 않다


오후 4:21 2023-12-30
1. 납득할만한 리소스매니저를 만들어서 이식하자
2. imgui 이식하자
3. Renderer 이식하자
4. 인자전달을 캡슐화하자

오후 6:52 2023-12-30
엔진의 최상단 오브젝트가 있어야할듯? 

리소스 객체를 만들자

push_back을 emplace_back으로 바꾸자
-> 이거 안됨                                                                                 




오후 2:33 2023-12-31
[내가 할 것]
1. 생성시점을 정리한다.
2. 구조체로 감싼다
3. using 혹은 define으로 정리한다.
4. object를 팩토리로 만든다.
5. object의 내용을 빌더로 채운다

6. 리소스매니저를 만든다
	ㄴ 리소스클래스를 만든다.
	ㄴ 

[요청사항]
1. 사운드 포인터를 반환하는 함수가 필요함
	ㄴ 그래야 리소스를 받아서 저장할 수 있음
2. 사운드 포인터를 받아서 사운드를 재생하는 함수가 필요함


오후 3:09 2023-12-31
어떻게 load 할 것인가? 

1. FileType과 파일명을 넘겨주고 
내부 스위치문으로 생성방법을 다르게 가져간다

void LoadFile(FileType filetype, std::string filename)
{
	// 임시변수 
	Resource* m_temp = new Resource;

	switch
	{
		case BitMap:
		// 이렇게 저렇게 해서 리소스클래스에 이렇게 넣는다
		break;

		case sound:
		// 이렇게 저렇게 가져와서 리소스 클래스에 넣는다.
		break;
	}

	// 만들어진 리소스 포인터를 벡터에 보관한다.
	m_resources.push_back()
}

2. 펙토리를 이용한다

class ResourceFactory
{
public:
	Reosurce* CreateResource();

}

Reosurce* ResourceFactory::CreateResource() { return new Resource; }


3. 팩토리를 이용한다  
// 빌더를 갖고 있다면? 

class ResourceFactory
{
public:
	Reosurce* CreateResource();
	// 빌더
	void LoadResource(fileName)
}

Reosurce* ResourceFactory::CreateResource() 
{
	 return new Resource; 
}


--------------------------------
오후 4:14 2023-12-31

리소스를 만들고 싶어
-> 리소스매니저에서 로드 리소스를 호출한다.

1. 어떤 리소스인지 모르지만 파일명으로 어떤 리소스든 호출하고 싶다.

2. 템플릿 타입정도는 적어줄 수 있다.
	ㄴ 템플릿 load함수로 자료형마다 특수화 해주어야 한다.
		-> 너무 귀찮다 바보같다

3. 어떤 리소스를 받을지 enum타입을 함께 넣어줄 수 있다.
	ㄴ 내부에서 스위치문으로 동작한다. 
		-> 멋이 없음

4. 빌더/팩토리를 사용한다
	ㄴ 어차피 리소스는 리소스이기만하면 되니까 팩토리로 생성
	ㄴ 리소스 내부 채우기는 빌더로 채운다.

------------------------------------------------------------------------------------------------
|| 리소스 매니저			||	리소스매니저			||
||	ㄴ 리소스팩토리		or		ㄴ 리소스빌더		||
||		ㄴ 리소스빌더	||			ㄴ리소스팩토리	||
------------------------------------------------------------------------------------------------

--------------------------------------------
||  리소스매니저			||
||	리소스 디렉터		||
||		ㄴ 리소스 팩토리	||
||		ㄴ 리소스빌더	||
--------------------------------------------

뭐가 맞는지 모르겠다.

리소스 펙토리만 템플릿화 하고 빌더는 상속구조를 가져가면 괜찮을지도?

--------------------------
오후 4:58 2023-12-31
[결정]
인자를 넘겨주고 팩토리로 만들기로 한다.

리소스펙토리를 추상화해서 
분기마다 새로운 리소스펙토리를 만들어줄까? 
하지만 리소스를 만들때마다 펙토리를 만드는건 너무 바보같다
펙토리는 리소스매니저가 생성될때 에초에 갖고 있는게 좋을듯

그런데 이러면 리소스가 추가될때마다 리소스매니저와 새로운 펙토리를 계속 넣어주어야한다.


리소스 종류가 추가되어도 리소스매니저를 수정하지 않으려면 어떠헥 해야돼!?!?!!?


오후 5:55 2023-12-31
리소스를 추상화한다? 

오후 8:16 2023-12-31
비트맵을 만든다고 하자
비트맵을 만들기 위해서는 인자전달이 필요하다
가변인자 템플릿? 

오전 11:56 2024-01-01


Bitmap을 load한다고 생각하자
1. 리소스 매니저의 LoadResource<HBitmap>(std::string fileName) 함수실행
2. LoadResource<HBitmap>함수 내부에서 CreateResource<HBitmap> 함수실행
3.  CreateResource<HBitmap>함수는 Resource<HBitmap>을 반환한다.
	// Resource<HBitmap>에 실제 데이터를 넣어야함

4. 팩토리 내부의 Director에서  CreateData<HBitmap>실행
	-> 여기에서 HBitmapBuilder를 실행한다.
	-> Director가 HBitmapBuilder를갖고 있어야 한다
	-> 어떻게??? 
	1) 템플릿을 만들고 데이터별로 템플릿을 특수화해준다
	2) 다른 '어떤방법'을 사용한다.
		어떤 방법 : T 타입을 이용해서 생성하는게 아니라 적절한 빌더를 넣어주는 방법


오후 2:52 2024-01-01
Resource객체에 Move, Copy 생성을 구현하자
























||||||| .r58
+ 메모리누수검사를 추가하자=======
+ 메모리누수검사를 추가하자

오후 4:08 2023-12-20



[프로그램을 실행한다.]

1. 초기화
2. Update & Render
/-------------- Loop ------------------/
	[[게임이 돌아간다]]
	1) Scene생성
	2) Update & Render

	//-------------- Loop ------------------//
	//--------------------------------------//
		(1) 오브젝트 생성
		(2) Update & Render
		(3) 씬 종료
	//--------------------------------------//	
	//--------------------------------------//	

	3) Scene 삭제 || 보관
/--------------------------------------/
3. 게임종료



1. Entity는 컴포넌트를 저장한다.
2. 컴포넌트는 IComponent를 상속받아 각각의 기능을 담당한다.


3. Scene은 현재 게임에 사용되는 오브젝트들을 저장한다.
4. 오브젝트들은 Entity다
5. 

-------------------------------------------------------
1. Scene 매니저를 만든다.
+ Scene을 만든다.

2. Object 매니저를 만든다
+ 오브젝트를 만든다. 


----------------------------------
|| Scnene			||
||	ㄴ Object(Entity)	||
||		ㄴ Component	||
----------------------------------

1. Scene을 만든다.
	-> Scene은 Scene매니저에서 생성한다.
2. Object를 만든다.
3. Component를 만든다.



------------------------------------
player : hp, ulf....  

object << component 

player
- hp
- mp

오브젝트를 만든다 -> SceneInit
이 시점에 컴포넌트들을 생성하고
오브젝트에 붙인다.! 


오후 8:27 2023-12-26

리소스 매니저는 Scene이 갖고 사용해야한다
그러면 
engine -> SceneManager -> Scene까지 가야함


오후 1:40 2023-12-27


1. 컴포넌트를 생성하고 저장하는 부분을 
Gameobj로 옮기자 -> (현재 objManager에 잇다)

2. 화면에 올라오는 내용을 obj단위로 분리하자

3. 분리된 obj들을 component단위로 분리하자

4. obj에 붙어있는 component 들을
사용하는 component를 만들자

5. Scene을 상속받는 실제 사용되는 Scene을 만들자

6. 너무 많은 매개변수를 구조체로 한 번에 넘겨주자



----------------------------------

오브젝트 1
-> 그림을 그린다.
	<BackGround>
	- 1) 위치, 크기, 리소스를 갖고 있는다.
	- 2) 리소스를 갖고 있는다.

	<Render>
	- 1) 위치, 크기, 리소스를 바탕으로 그린다
오브젝트 2
-> Text를 출력한다. 
	<printer>를 기본으로 하자


----------------------------------
Time을 어떻게 사용할지 결정해야한다.
-> 타임매니저 포인터를 받기로함

---------------------------------
이니셜라이즈를  컴포넌트에 갖다 박는다
DrawSet이 무분별하게 복사되는중, 해결해야한다
컴포넌트들이 너무 일회성이다.

-----------------------------------
오후 4:06 2023-12-29
이제 엔진은 컴포넌트 단위로 (간신히)돌아가고 있다.
마구잡이로 만들어서 많은 문제가 남아있는데 어떻게 해결할까? 

[문제점]

8. 리소스매니저의 인터페이스를 만들자
	L 비트맵을 뽑기위해서 만들었던 리소스매니저의 인자들이 
	wstring과 Hbitmap인데 모든 리소스에 범용적으로 사용할 수 없다
	특히 GetResource는 하나의 리소스를 반환하면 IResource매니저 자체가
	의미없이 작동한다.
	1) Resource라는 객체을 만들어서 리턴한다.
		ㄴ 자료형이 추가될때마다 Resource 클래스를 손봐야한다.
	2) 템플릿으로 만든다.
		-> 함수만? 혹은 클래스 전체를? 
		-> 인터페이스로 만들고 또 템플릿을????? 
			ㄴ인터페이스에는 템플릿을 넣을 수 없다

10. 리소스매니저의 unorderdmap의 데이터를 어떻게 지우지? 


1. 인자들이 너무 더럽게 전달된다.
	ㄴ 매개변수가 너무길다.
	ㄴ 무분별하게 '복사' 된다

9. Define을 어디에 어떻게 넣어야 할까? 
	헤더를 만들어서 추가해야 하나? 
	ㄴ define과 헤더에 넣고 쓰기 차이를 모르겠다.
	ㄴ getcomponent<>() 로 사용하기에 너무길다.


2. 너무 많은 누수..! 
	ㄴ스마트 포인터로 바꾸면 되지 않을까? 
	ㄴ 혹은 제대로 할당을 해제해주는 구간이 필요하다

3. 컴포넌트들이 너무 일회성이다.
	ㄴ 재사용가능하게 만들려면 어떤걸 고려하고 어떻게해야지? 

4. input매니저를 배껴온거라서 사실 사용법 이해가 안됨

5. component들의 '초기화' 부분이 없다
	ㄴ 언제 하지? 

6. audio 는 컴포넌트화 시키지 못했다.

7. 모든 컴포넌트가 Update와 Render를 필요로 하진 않는다.
	ㄴ 하지만 모두 갖고 있어; 좋지 않다


오후 4:21 2023-12-30
1. 납득할만한 리소스매니저를 만들어서 이식하자
2. imgui 이식하자
3. Renderer 이식하자
4. 인자전달을 캡슐화하자

오후 6:52 2023-12-30
엔진의 최상단 오브젝트가 있어야할듯? 

리소스 객체를 만들자

push_back을 emplace_back으로 바꾸자
-> 이거 안됨                                                                                 


오후 2:33 2023-12-31
[내가 할 것]
1. 생성시점을 정리한다.
2. 구조체로 감싼다
3. using 혹은 define으로 정리한다.
4. object를 팩토리로 만든다.
5. object의 내용을 빌더로 채운다

6. 리소스매니저를 만든다
	ㄴ 리소스클래스를 만든다.
	ㄴ 

[요청사항]
1. 사운드 포인터를 반환하는 함수가 필요함
	ㄴ 그래야 리소스를 받아서 저장할 수 있음
2. 사운드 포인터를 받아서 사운드를 재생하는 함수가 필요함
	ㄴ 이건 뭘 만들때 실제 써보고 요청하는게 맞다


오후 3:09 2023-12-31
어떻게 load 할 것인가? 

1. FileType과 파일명을 넘겨주고 
내부 스위치문으로 생성방법을 다르게 가져간다

void LoadFile(FileType filetype, std::string filename)
{
	// 임시변수 
	Resource* m_temp = new Resource;

	switch
	{
		case BitMap:
		// 이렇게 저렇게 해서 리소스클래스에 이렇게 넣는다
		break;

		case sound:
		// 이렇게 저렇게 가져와서 리소스 클래스에 넣는다.
		break;
	}

	// 만들어진 리소스 포인터를 벡터에 보관한다.
	m_resources.push_back()
}

2. 펙토리를 이용한다

class ResourceFactory
{
public:
	Reosurce* CreateResource();

}

Reosurce* ResourceFactory::CreateResource() { return new Resource; }


3. 팩토리를 이용한다  
// 빌더를 갖고 있다면? 

class ResourceFactory
{
public:
	Reosurce* CreateResource();
	// 빌더
	void LoadResource(fileName)
}

Reosurce* ResourceFactory::CreateResource() 
{
	 return new Resource; 
}


--------------------------------
오후 4:14 2023-12-31

리소스를 만들고 싶어
-> 리소스매니저에서 로드 리소스를 호출한다.

1. 어떤 리소스인지 모르지만 파일명으로 어떤 리소스든 호출하고 싶다.

2. 템플릿 타입정도는 적어줄 수 있다.
	ㄴ 템플릿 load함수로 자료형마다 특수화 해주어야 한다.
		-> 너무 귀찮다 바보같다

3. 어떤 리소스를 받을지 enum타입을 함께 넣어줄 수 있다.
	ㄴ 내부에서 스위치문으로 동작한다. 
		-> 멋이 없음

4. 빌더/팩토리를 사용한다
	ㄴ 어차피 리소스는 리소스이기만하면 되니까 팩토리로 생성
	ㄴ 리소스 내부 채우기는 빌더로 채운다.

------------------------------------------------------------------------------------------------
|| 리소스 매니저			||	리소스매니저			||
||	ㄴ 리소스팩토리		or		ㄴ 리소스빌더		||
||		ㄴ 리소스빌더	||			ㄴ리소스팩토리	||
------------------------------------------------------------------------------------------------

--------------------------------------------
||  리소스매니저			||
||	리소스 디렉터		||
||		ㄴ 리소스 팩토리	||
||		ㄴ 리소스빌더	||
--------------------------------------------

뭐가 맞는지 모르겠다.

리소스 펙토리만 템플릿화 하고 빌더는 상속구조를 가져가면 괜찮을지도?

--------------------------
오후 4:58 2023-12-31
[결정]
인자를 넘겨주고 팩토리로 만들기로 한다.

리소스펙토리를 추상화해서 
분기마다 새로운 리소스펙토리를 만들어줄까? 
하지만 리소스를 만들때마다 펙토리를 만드는건 너무 바보같다
펙토리는 리소스매니저가 생성될때 에초에 갖고 있는게 좋을듯

그런데 이러면 리소스가 추가될때마다 리소스매니저와 새로운 펙토리를 계속 넣어주어야한다.


리소스 종류가 추가되어도 리소스매니저를 수정하지 않으려면 어떠헥 해야돼!?!?!!?


오후 5:55 2023-12-31
리소스를 추상화한다? 

오후 8:16 2023-12-31
비트맵을 만든다고 하자
비트맵을 만들기 위해서는 인자전달이 필요하다
가변인자 템플릿? 

오전 11:56 2024-01-01


Bitmap을 load한다고 생각하자
1. 리소스 매니저의 LoadResource<HBitmap>(std::string fileName) 함수실행
2. LoadResource<HBitmap>함수 내부에서 CreateResource<HBitmap> 함수실행
3.  CreateResource<HBitmap>함수는 Resource<HBitmap>을 반환한다.
	// Resource<HBitmap>에 실제 데이터를 넣어야함

4. 팩토리 내부의 Director에서  CreateData<HBitmap>실행
	-> 여기에서 HBitmapBuilder를 실행한다.
	-> Director가 HBitmapBuilder를갖고 있어야 한다
	-> 어떻게??? 
	1) 템플릿을 만들고 데이터별로 템플릿을 특수화해준다
	2) 다른 '어떤방법'을 사용한다.
		어떤 방법 : T 타입을 이용해서 생성하는게 아니라 적절한 빌더를 넣어주는 방법


오후 2:52 2024-01-01
Resource객체에 Move, Copy 생성을 구현하자

--------------------------------------
오후 8:41 2024-01-03
리소스엔진.. 쓸 수 있어! 

director의 역할을 factory로 옮겨주자





오후 5:32 2024-01-04

리소스매니저 구조를 축소하고(resourceDircetor 삭제)
loadResource함수의 매개변수를 줄였다.

교수님들의 조언이 너무 나이스 했다.

템플릿에서 decltype으로 자료를 추론하는 방식으로
리소스가 갖고 있는 builder를 호출 할 수 있엇다.

리소스가 lvalue 형태고 갖고 있어서 자료형이 넘어갈때
T& 형태로 넘어가서 개망했는데
강동완 교수님이 remove_ref 써보라고 해서 살았다.
와.. 이게 돌아감

덕분에 이제 enum 빌더타입도 필요없다.

LoadResource<자료형>("파일명", 빌더타입)
-> LoadResource<자료형>("파일명")

미춋다

하지만 문제가 있어

[한계]
-> 자료형으로서 만들어줘야만 만들 수 있음

-> 자료형이 본인의 빌더를 알고 있어야함
	이 정돈 괜찮을지도? 

 💀 자료를 만들때마다 빌더를 만드는중 💀
-> 이미 빌더가 존재하면 만들지 않도록 해야겠다.
	1. SetBuilder 함수가 빌더를 생성하는 것은 잘못되었다.
		ㄴ create 함수로 바꾼다.


loadResource의 동작방식을 재정의 할 필요가 있다.

1. builder를 찾는다.
	ㄴ 존재여부 확인
	-> 어디에 ? 어떻게 존재할 것인가? 
	팩토리에 : ??(맵?) 로 존재한다.
		ㄴ 없다 -> 생성한다.
		ㄴ 있다 -> 세팅한다.
2. builder를 세팅한다.
3. 리소스<T>를 만든다.
4. 데이터를 생성한다.
5. 자료형에 맞는 리소스<T>를 생성한다.

오후 5:00 2024-01-05
오브젝트가 씬을 알고있으면 유용함 - 킹기태
해야할 일을 정리하고 시작하자

오후 1:17 2024-01-06
무엇을 해야하나! 

1. 리소스매니저를 이식한다
-> 그리고 돌아가게 만든다.
	1) BitMapManager
	2) soundManager

2. 객체의 생성시점을 정리한다.
	+ 인자의 전달 방법을 정리한다. 


-------
리소스 매니저 사용법
1. 자료형을 만든다.
-> Reasource에 들어갈자료형
	-> 자료형에는 필요한 데이터 해당자료형의 빌더가 포함된다.
2. 빌더를 만든다.

오후 6:31 2024-01-06
빌더마다 필요한 인자가 있다... 우짜지;

오전 11:21 2024-01-07
일단 빌더에서 초기화 함수를 만든다.


엔진을 상속받고 
생성데이터를 Get함수로만 남겨놓으면 개꿀아님? 


오후 1:19 2024-01-07
기괴하게 리소스엔진이 돌아가고 있다.

옳은가? 
모르겠다;;

오후 2:04 2024-01-08
상속받았을때 매개변수의 대한 내용을 잘 인지해야한다.
나는 인지하지 못했고
왜 아직도 이게 이렇게 돌아가는지 모른다;

오후 3:17 2024-01-08
모르지만 계획이 없으면 아무것도 할 수 없다! 
1. 사운드의 재생관리를 완전히 resource매니저 단위로 몰아주자.
	-> GetResource로 돌아가는 Sound함수가 필요함
2. 


----------------------------
생성시점 정리

InputManagersingleton 

💡[MockeryEngine]
  <가져옴>
	2) HINSTANCE m_hInst;
	3) HWND m_hWnd;
  <생성됨>
	1) SceneManager* m_secneManager;
	2) TimeManager* m_timeManager;

	DrawSet* m_Draw;
 	HBITMAP m_bit;
 	BITMAP m_bm{};

------------------------------------------------------------------------------------
	💡[SceneManager]
	  <여기에만 있음>
		Scene* m_currentScene;
		std::unordered_map<SceneState, Scene*> m_sceneMap;

	  <가져옴>
		TimeManager* m_timeManager;

	  <생성됨>
		KSL* m_soundKSL;
		ResourceManager* m_resourceManager;
		ObjectManager* m_objManager;

------------------------------------------------------------------------------------
		💡[Scene]
		  <여기에만 있음>, <생성됨>
			std::vector<GameObject*> m_objects;
			GameObject* m_object;
		  <가져옴>
			DrawSet* m_drawSet;
			ResourceManager* m_resourceManager;
			ObjectManager* m_objManager;
			TimeManager* m_timeManager;
	



sound* 로 소리를 재생할 수 있는 함수

1. objManager가 제대로 작동하게 해야함

update에 deltaTime추가


오후 9:17 2024-01-08
리소스매니저 수정사항
-> 이름이 같은 리소스는 덮어씌워짐;

왜 이미 지웠는데 다시 돌아와서 지우는거지? 

빌더들은 어떻게 소멸시켜주지? 

오후 12:56 2024-01-09
메모리누수 다 잡았다! 

이제 게임이 돌아가는 공간을 옮기고 그래픽스 엔진을 붙인다! 



-------------------------------------------

[엔진 & 게임 분리]

-> 어떻게? 

demo에서
scene을 상속받은 무언가에 만들고
만든 씬의 포인터를 전달해주면
돌아가는건 엔진안에서 돌아간다? 

[Demo]
-> 뭔가 만들어져야됨

[Engine]
-> 게임을 만들기위한 기능을 갖춘다.

[graphics]
-> 그림을 그린다.


상황으로 가정해보자
	* 캐릭터를 그린다

1. 'Demo'프로젝트를 시작한다.
	1) 이니셜라이즈
		- 윈도우 초기화
		- 게임엔진 초기화
		- 그래픽스 엔진 초기화

	2) 루프 작동
		(1) 게임엔진을 업데이트
		(2) 그래픽스 엔진을 업데이트
	
	3) 랜더
		()



--------------------------------------------

오후 5:52 2024-01-11
너무 오랜만 😓


1. mesh와 카메라 컴포넌트를 만든다
	1) 내용은 그래픽스 엔진에서 가져올 것이기 때문에 껍데기만 만들자
		카메라를 엔진에서 사용해야 한다면 엔진이 카메라를 알아야하겟네
	2) 메쉬는 컴포넌트인지 리소스인지 구분해야한다
		: 나중에 작업할까 ?

2. 엔진과 클라이언트를 분리한다
	-> 구조만 구상할 수 있으면 어렵지 않을 것 같다
	심지어 간단한 구상정도는 있다.
	
	엔진에서 scene을 상속받은 클래스를 만들고
	내용을 작성하고
	작성한 내용을 전달해서 
	engine 안의 scene에서 돌아가도록 만드는 것이다.

	하지만 이정도 개념으로는 무언가 만들기에 부족하다
	그렇다고 하나하나 물어보면서 시키는대로 만들고 싶진 않잖아? 
	가즈아ㅏ아아아마머ㅏㅣ;ㅁㄴㅇ리;ㅓㅏㅁㄴㅇ러ㅏ


잘게 구분하는게 정리에는 도움이 별로 안되는것 같기도 하다

오후 7:31 2024-01-11
Scene을 프로젝트 단위로 분리하면 좋을 것 같다
방법은 모르겠다.

Scene을 분리해서 scene정보를 저장하는 프로젝트를 따로 만들고
그 프로젝트 안에서 scene을 상속받은 실제 게임에서 돌아가는 scene들을 작성한 뒤에
포인터를 얻어와서 엔진의 update에 이식하면 게임과 scene이 
분리되는 느낌적이 느낌을 얻어을 수 있지 않을까? 

물론 아주 만족스러운 계획은 아니다 

이러면 scene메이커 프로젝트가 엔진의 거의 대부분을 알아야 한다.
그리고 engine 에서는 메이커프로젝트에서 만든 scene을 엔진 안에서 돌려야 하니
또 scene 메이커를 알아야 한다.

scene maker -> engine
engine -> scene maker

서로를 알고.. 알고.. 알고.. 

맘에 들지 않는다
좀 더 멋진 분리 방식이 있을거라고 생각한다.

하지만 내가 생각하는 방식은 결국 
scene을 상속받아 실제 scene을 그리는 방식과 다르지 않다.

이러면 상속받은 scene 전까지는 엔진과 분리될 것이다.. 라고 생각한다.

그러니 일단 할 수 있는 일을 하자

scene을 상속받고 그 scene을 돌린다!  



오후 7:47 2024-01-11
규석이와 대화해보았다.

규석이는 Scene을 만드는 새로운 dll을 만들려고 했다고 하네? 
새로운 library를 만들어야 한다는 방향성이 틀리진 않았나보다.

나는 엔진이 scene메이커를 들고 있고 scene메이커가 
엔진을 들고 있는 구조 밖에 생각 못했는데

규석이는 새로운 프로젝트가 엔진과 scene메이커를 들고 실행하는 방법도 있겠더라 했다

그러면 맘에 들지 않는 루프구조를 해결할 수 있을지도? 



오후 8:03 2024-01-11
1. scene을 추상화한다.
	-> 이제 너는 내용을 갖고 있을 필요가 없다.
2. titleScene으로 구현을 옮긴다.

3. scene매니저에서 titleScene을 사용해서 update를 돌리게 하자! 



오후 8:30 2024-01-11
상속받은 scene으로 돌아가게 했다.
멤버가 scene에 있을지 아래쪽에 있을 지는 생각해보자

세팅을 set함수로 해주는 좋을 것같다.
drawset은 사라질 것이라 상관없지만 나머지는 화살표로 넣고 빼고 하면
마감처리가 제대로 안됀 느낌이랄까

오전 9:07 2024-01-12
나의 오브젝트매니저는 사실 오브젝트를 생성만하지 관리하진 않는다

승운이는 이 부분이 맘에 안든데
'생성과 삭제는 같은 곳'에서 이루어져야하지 않냐고! 

그런데 너무 맞는말이었다.
그래서 앞으로 개조해야할 부분이 하나 생겨버린거지~! 

오브젝트 매니저에서 생성삭제를 하기로 하고

오브젝트의 생성, 삭제, 업데이트, 랜더 여부를 scope 단위로 관리해야겠다.


모든 씬을 미리 생성해놔도 될듯? 
오브젝트 관리만 하면 되니까


오전 9:51 2024-01-12
deltaTime을 float으로 바꾸는게 좋을 것 같다.
그래픽스 엔진까지 내가 만든다면 상관없겠지만
많은 연산이 double보다는 float 으로 이루어지고 있는데
deltaTime이 double이라면 할 때 마다
캐스팅이 계속 이루어져야하니까 영 좋지 않을 것 같아

오전 10:01 2024-01-12
testscene을 만들고 changescene이 돌아가는지 확인하자

오후 6:54 2024-01-12
오류가 폭발한다.

scene두개를 써서 그런것같다.


오후 8:10 2024-01-12
원인 모를 무언가를 해결했다.
오류가 엄청 많이 떴는데

아마 인클루드에서 실수 한 것 같다.
아 오류 고치는 거 정말 짜증난다

오후 4:33 2024-01-13
오늘은 어떤 멋진 일이 일어날까~ ⭐

1. 상속 받은 씬들이 유기적으로 돌아갈 수 있게 만들자
	1) 상속받은 scene을 생성하고 돌아갈 수 있게 해야한다.
		-> 지금 여기서 오류나는 중 인클루드 관련 오류들인듯

	2) scene change함수가 돌아가야 한다.
		-> scene change 가 이루어지는 것이 최우선  이게 안되면 의미가 없다

	3) scene을 분리해서 새로운 라이브러리로 만든다.
		-> 위의 과정은 이것을 위한 것이다.
			규석이는 dll로 만들라고 하는데 그게 되겠냐고~ ~

		-> scene의 내용의 관한 데이터를 분리하는게 목적이다.
		-> 아예 파일단위로 분리해서 불러올 수 있으면 제일 좋을지도! 
		하지만 이건 '그' 다음이다.

2. titlescene과 examplescene은 둘다 scene을 상속받고 있기때문에
scen매니저에 인클루드하면 Scene을 재정의한다는 오류가 나온다

문제를 정의 해보자



하나의 클래스(Root)를 상속받은 두개의 클래스(A, B)를 
외부 클래스(Other)에 인클루드 했다.
그리고 외부클래스(Other) 안에서 부모(Root)의 대한 재정의 오류가 발생한다.

-> scene에서 #pragma once 전처리가 지워져 있었다.
지운건지 지워진 건지 모르겠지만.. 
전처리를 추가함으로써 가볍게 해결;

문제를 온전히 정의하고 나니 생각보다 명쾌하게 해결되었다. 

현재 리소스의 load를 Scene단위로 하고 있는데 문제가 발생
-> 사운드리소스를 생성하는 클래스를 삭제해서 문제였다
소멸시점을 다시 만들어야할듯

오브젝트를 만들고 지우는건 했는데 오브젝트 맵을 클리어해주지 않아서 문제가 발생했다.
오브젝트 맵을 클리어하고 문제 해결! 

오후 7:15 2024-01-13
진짜 문제로 돌입한다.
그전에 정리 먼저 해야할듯

오후 8:24 2024-01-13
타임매니저 업데이트 시점이 조금 이상할지도...? 

현재 chaneScene 함수는 scene매니저 안에 있다.
하지만 scene변경 요청은 Scecne안에서 이루어져야하지 않나?

오후 8:51 2024-01-13
Scene을 분리하려는데
Scene마다 다른 내용은 Scene Start부분 밖에 없었다! 
scene start()의 내용을 정리하면
	1. 생성에 관여하는 외부 포인터를 가져온다
	2. scene에 필요한 리소스를 가져온다
	3. 오브젝트(+컴포넌트)를 생성한다. / 저장한다.
	4. 컴포넌트에 정보를 세팅한다.

내가 분리하고 싶은 내용은 
오브젝트의 동적인 생성과 컴포넌트의 세팅이었다.

라는건 에디터(툴) 에서 이루어져야 하는 내용인 것이다! 
내가 만들고 싶은건 툴이었다고!! 
만들어진 Scene의 저장의 관한 내용은 다시 생각해봐야겠지만

에디터를 사용하기 위해서는
조립이 완료된 엔진이 필요하다
-> 그래픽스 엔진을 붙이자! 

오후 9:37 2024-01-13
그래픽스 엔진 붙이기 시작

오후 1:22 2024-01-14
진짜 시작

오후 4:10 2024-01-14
엔진에 그래픽이 붙었다.
박스가 나온다
하지만 오브젝트 단위로 움직이는게 아니기 때문에
고칠게 산더미다

오후 8:45 2024-01-14
오브젝트가 랜더 정보를 갖고 있고
해당오브젝트를 랜더링 하는 시점에 랜더 함수에 정보를 넘겨줘서
그려야하지 않을까? 

그러려면 랜더함수 자체가 필요할듯? 

애들이랑 얘기해보자

오전 10:00 2024-01-15
랜더함수와 사운드포인터 재생함수는 필요하다! 
해주기로 했지! 

나는 이제 씬을 dll 로 분리해서 핫 리로드 기능을 사용할 수 있게 해보자! 

scene을 작성하고 scene 객체를 반환하자!

../core/inc
../x64/debug
ㅇㅇㅇ
KestrelSoundLibrary.lib;Graphics.lib;%(AdditionalDependencies)
$(SolutionDir)x64/Debug;%(AdditionalLibraryDirectories)



오후 9:26 2024-01-15
인풋매니저 손댓다


오후 9:47 2024-01-15
dll 로 프로그램 살아있는 상태에서 오브젝트 수정가능
-> 지렸다ㅇㅇ


오전 10:07 2024-01-16
InputManager가 dll 에 있는 녀석이랑 
엔진에 들어있는 녀석이랑 다르다

받아와서 써야 할듯? 
intputmanager 포인터를 만들고 받아와서 임시로 사용할까? 

오전 8:43 2024-01-18
inputmanager를 작동시키는 것 부터 시작한다.
안정적으로 dllScene에서 돌아가게 만들자

오전 9:07 2024-01-18
dll 에서는 여전히 dll 내부의 인풋매니저를 사용하고 있는 것이다
scene에서만 바꾼다고 전부 바뀌는게 아니다
-> input매니저를 싱글턴에서 매개변수 전달로 바꿀까? 

오전 11:42 2024-01-18
인풋매니저 작동방식을 싱글턴에서 변수전달로 바꾸면서 
매개변수안에서 제대로 인풋매니저가 작동하게 되었다.
but) 이제 키입력이 필요한 녀석들은 인풋매니저를 전달받아야한다.

[👨‍⚕️엔진정리를 해야한다 ]
dll 을 이용해서 scene 변경 기능을 만들었지만
원래 기능들이 많이 훼손되었다.

1. 원래 Scene들을 담아뒀다 내부적으로 재사용하는기능이 없어졌다.
2. 매개변수전달이 꼬였다. 클래스 변수에 직접전달하는 방식은 좋지 않다.
3. 현재 scene이 엔진에도 들어있고, dll에도 들어있다.
4. dll에서 scene내용을 변경하고 그 씬을 그대로 사용하는 방식을 사용하면 좋을듯? 
5. 이제 Scene이라는 내용은 엔진에 필요없다? 

[현재 문제]
scene 편집은 가능하지만 
한 번에 하나의 Scene만 가져오고 있다.
scene 맵을 전달해서 가져오면 어떨까?
	-> 맘에 들지 않는다.

핫리로드 기능을 버튼으로 만해야하나? 
함수 있을 것 같다
-> 일단 저장하면 자동 핫리로드 정도로 만족하자


1. #prgma로 바꿀것
2. objManager에서 생성삭제가  이루어질 것
3. dll을 사용하더라고 scenechange가 가능하도록 해야함




scene을 전달받는 부분 부터 확인해볼까 ?

4개의 매니저를 동시에 받을 함수가 필요할듯? 




해야한다 != 할 수 있는것

(안하면)우리팀이 눈물을 흘린다 == 해야한다 

8 == 일주일 + 1

=> 하루는 괜찮다! 

꽤 즐거운 하루하루를 
보낼 수 있다.

오후 12:43 2024-01-19

무엇을 해야하는가? 

1. 우리는 엔진을 이용해서 박스를 띄워야 한다.
2. 엔진의 사용법을 전달해야한다.
	- 리소스매니저	
	- 컴포넌트 만드는법 
	- 사용법

3. 엔진의 구조를 규석이에게 설명해줘야한다.

오후 9:09 2024-01-21
구글리모트가
맥북에서도 정말 잘 돌아가서 맘에든다
맥북에서 돌아가면 좋은점은 
마우스가 부트캠프에 비해 훨씬 잘 돌아간다는 점~! 

오전 9:46 2024-01-22
그래픽스 엔진을 들여다보고 어느시점에 뭐가 필요한지 보자

1. 
아래 부분이 Scene start 부분에서 이루어져야한다.

	void Box::Initialize()
	{
		BuildGeometryBuffers();
		BuildFX();
		BuildVertexLayout();
	}


scene start에서 이루어져야함
-> component안에서 호출? 
-> 랜더러포인터로 MeshData를 넘겨준다
	void Initialize();
	void LoadGeomerty(ASEParser::Mesh* meshData);

랜더러 포인터로 넘길 필요가 없다? 
-> 그럼 메쉬정보를 어떻게 받아가지? 
-> component, 적어도 scene에서는 받아야 하지 않나? 

entity에 id를 준다.




[기태꺼 배낌]
💡engine update 반환값을 설정해서 dt를 외부로 보내줄 수 있네

float ImpEngineModule::EngineModule::Update()
{
	float dt = _timeManager->Update();
	_inputManager->Update();

	// 충돌 처리 
	_collisionManager->Update(dt);

	_world->CleanUp();
	_world->Update(dt);
	
	return dt;
}


오후 12:27 2024-01-22
1. 컴포넌트
+ 
	1) 컴포넌트 제작
		(1) icomponent를 상속받아 component를 만든다.
		(2) 구현된 Scene에 컴포넌트 헤더를 추가한다.
	2) 컴포넌트 생성/추가
		(1) 구현된 scene에서 오브젝트 매니저를 이용해서 오브젝트를 생성한다
			m_objManager->CreateObject();
		(2) 오브젝트 매니저의 addcompoent함수의 템플릿 변수에 컴포넌트 자료형을 넣어준다.
		
2. 리소스 
	1) 자료형 제작
		- 사용할 type클래스을 만든다
		- type클래스에 자신의의 buidler를 스태틱변수로 만든다.
			* 빌더의 변수명은 m_buidler로 통일한다.
		- 스태틱으로 포함시킨 buidler를 nullptr로 초기화한다.

		- 리소스가 사용되는 scene에 #include 한다.
		
	2) 빌더 제작
		- iBuilder를 상속받아서 빌더 클래스를 생성한다. 
		- 데이터를 저장할 자료형을 생성한다.
		- 경로, 크리에이터를 이용해 데이터를 저장한다.

		- ReousourceFactory클래스에 빌더를 include한다.
		
	3) LoadResource
		리소스를 load 할 때는
		리소스매니저포인터를 이용해서 LoadResource<type>("파일명") 함수를 실행한다.

	4) GetReousrce
		리소스를 get 할 때는
		리소스매니저포인터를 이용해서 GetResource<type>("파일명") 함수를 실행한다.


	5) Resource Creator
		- 리소스를 제작하는데 필요한 정보를 전달하는 구조체이다.
		- 리소스를 만들때 필요한 내용을(hWnd, hinst 등.. ) 적당히 넣어서 사용하자

오후 2:46 2024-01-22
오브젝트 생성 후 nullptr넣어줄까? 
오브젝트 매니저에서 만들고, 저장하고 scene에서 참조하자


component에 start추가 하자




오후 4:16 2024-01-22
빌더와 리소스 구조 설명을 만들자
-> 만듬

오후 5:02 2024-01-22
LateUpdate 추가하자
-> 어디에 추가하죠 ?
	SceneManager
	
	Scene
	
	object
	
	component


TODO::
타입을 추상화 해서 릴리즈 함수를 한 번에 호출하자! 

오브젝트매니저가 오브젝트의 생성/삭제를  담당하게 한다
오브젝트의 생성/삭제 레이어를 만든다.

pch 없애고
#pragma comment(lib,"") 로 가져오는 방식으로 바꾸고
등등등 할거 많다!

Graphics엔진을 외부에서 가져오는 걸로 바꾸자	



1. 랜더러 안에 오브젝트는 언제만들어지는가?
	-> 랜더컴포넌트를(mash_renderer) editScene 할 때

2. 엔진 오브젝트가 가진 메트릭스를 어떻게 랜더러에서 갱신하는가?
	-> 메쉬랜더러를 생성할때 renderer를 갖는다


3. 엔진오브젝트가 랜더러 내부의 오브젝트를 아는가?(반대인가? 둘다인가? 
-> id로 알고 있다.



메모린누수? 잡을 수 없다
미룬다


1. scene이 끝날 때 
내부의 컴포넌트를 삭제하는 중에 renderer포인터를 삭제하면 안된다
이부분에 대해서 고민해봐야한다.


2. 헤더위치에 대해 고민해봐야한다.
헤더위치에 따라 되고 안돼는게 너무 많다


		월		화		수		목		금		토		일
						24		25		26		27		28
										<fbx띄우기>
graphics 								 	AddMesh()			리소스매니저완성
engine								 	Trnasform			ObjectID
		------------------------------------------------------------------------------------------------------
		29		30		31		1		2		3		4
					
graphics 					Animation			바운더리 박스 만들기					
engine	FSM만들기			Animator Controller	충돌 처리			충돌 완성
		------------------------------------------------------------------------------------------------------
		5		6		7		8		9		10		11
				[FPS인 무언가]			[프로토 타입]			[알파완성]
graphics 							 	
engine				
		------------------------------------------------------------------------------------------------------
		12		13		14		15		16		17		18
										[베타 완성]
graphics 							 	
engine	
		------------------------------------------------------------------------------------------------------
		19		20		21		22		23		24		25
				[최종버전]	[테스트]		[완성-빌드마감]	[발표]
graphics 							 	
engine	
		------------------------------------------------------------------------------------------------------


오후 7:27 2024-01-24
1. 저번 시간에 받은 피드백을 반영한다.
	- objManager를 고친다.

2. Transform을 만들자

2.5 path 매니저를 만들자

3. FSM 조사 및 만들기

3. 충돌처리를 만들자
	- 컴포넌트, 매니저

[저번 시간에 받은 피드백을 반영한다]
- objManager를 고친다.
	리소스매니저에서 m_gameObj가 남아있는건 너무 별로다
	객체를 반환하고 반환한 객체를 받아서 사용하는 편이 좋을 것이다.

-> ObjManager 를 고치니까 정말 쓸모없어졌다;


id Generator를 만들고 오브젝트 매니저에서 사용하자
-> 일단 스태틱 카운트를 늘이는 방식으로 만들었다.

오브젝트관리를 objManager가 하도록 바꿔야 한다.
-> 후순위 나중에 꼭하자

트랜스폼을 만들자, 그리고 키입력으로 어떻게 저렇게 움직일 수 있게 만들자

부모가 필요한 오브젝트와 그렇지 않는 오브젝트가 있겠지? 구분해서 사용해볼까


오후 4:20 2024-01-28
FSM을 만들어보자

FSM은 '상태'를 관리한다.
상태란 BaseState를 상속받은 각각의 클래스이다.

1. FSM은 객체를 입력받는다.
2. 객체의 '현재상태'를 확인하고 '다음상태'로 스테이트를 변경한다.
	- '현재상태'와 '다음상태'가 같다면 아
	무것도 하지 않는다.
	- '현재상태'와 '다음상태'가 다르다면 현재상태를 다음상태로 갱신하고 변경한다.



class BaseState;
class DirectY;

class FSM
{
public:
	FSM(BaseState* baseState);
	~FSM();

	void ChangeState(BaseState* nextState);
	void UpdateState(float deltaTime);
	void RenderState(DirectY* directY);

private:
	BaseState* m_curState;
};

	// 상태의 변경여부는 '현재상태' 가 결정한다.
	// 현재 상태는 자신이 변경될 수 있는 상태를 모두 알고 있어야한다.

오후 5:39 2024-01-28
FSM만들었다.
파일시스템을 이용해서 PathManager를 만들어보자
-> 이용성 파일시스템은 우리에게 필요없을지도? 

오후 6:21 2024-01-28
1. SceneChange를 가능하게 만들어보자
원래 됐자너 ㅠㅠ 

오후 7:02 2024-01-28
state는 어떤 형태로 저장되어있어야 할까? 
1. 컴포넌트
2. 리소스
3. 무언가? 

오후 7:16 2024-01-28
현재 씬마다 겹치는 리소스가 있으면 씬 실행마다 무조건 생성하고 있다;
이건 해결을 해야하지 않을까
	1. 리소스 생성시점을 변경한다.
		-> 모든리소스를 처음 부터 갖고 있어야 할까? 
	2. 리소스 중복생성을 막는다.

오후 8:21 2024-01-28

Scene을 lib안으로 옮기기로 결정
일단 Scene들을 복사한다.

엔진에서 dll부분을 제거하는중

제거완료

오후 12:49 2024-01-30
컨트롤러 컴포넌트를 만들자

이동행렬을 만들어두고
가산해준다.

1. state에서 정해지는 속도를 받아서 행렬을 만들고 곱해준다.
2. 컨트롤러 내부에 설정을 해두고 값을 곱해서 적용한다? 

방향벡터를 받아서 곱하면 xyz따윈 필요없지 않을까? 
 축 이동 함수를 만들고 

나는 바보당	false
나는 오해강이당	true
나는 수염난 몽골 사냥꾼 아저씨당 true
나는 리소스 매니저 마스터당	true
나는 깜짝 놀라는 오해강이당	True (2024.1.30)
나는 초초천재 오해강이당	....e



유니티에 존재하는 좌표는 
world transform matrix 이다.

원점에 대한 좌표는 될 수 있다.
원점에 대해서는 ? 가 맞지
하지만? 

부모의 대한 모든 transform을 가산한 값이라면 ok일 것
최종 부모끼리 비교 해도 무방하지 않을까? 


오전 10:01 2024-01-31
트랜스폼에 추가로 존재해야 하는것
1. 부모가 존재하는가
2. srt set함수( local / world )
	+ 합쳐서 m_world로 만들어야함
3. 

디컴포즈 없이 하려면 -> m_world를 받아오는 것이아니라

m_scale		을 처음부터 여기서 세팅해주나? 
m_rotation		
m_translation

	// 벡터를 이용해서 월드를 조립
	void UpdateTransform();	

	// 쿼터니언 값을 오일러각으로  변환
	Vec3 ToEulerAngles(Quaternion q)

	

오전 10:52 2024-01-31
1. what I do? 
	-> transform 레퍼런스를 토대로 고치는 중
	-> 거의 다함, 내용 이해하고 있음

2. 모델주소를 넘겨주려면 리소스형태로 만들어야함
-> fbx, texture 리소스빌더 만들어 놓겠다.
-> 폴더 구분은 규석이와 상의하자

3. 메쉬에 필요한정보 -> fbx에서 필요한 거겠지? 

4. 나는 2개만 따로 넘겨주면 되는지? 
아니면 fbx와 텍스쳐를 넘겨줄 때 유용한 구조가 따로 있는지? 

오전 11:23 2024-01-31
1. transform완성
2. fbx리소스 / 빌더 제작
3. 컨트롤러 개선
[transform을 만들자]
	-> 쿼터니언에서 막힘
	1) 쿼터니언을 받기도 하고 세팅도 하지만 쿼터니언으로 무언가 만들진 않음? 
	2) 


이런 방식이라면? 
컨트롤러는 local에 개입해야하나? 

월드를 set하는게 의미가 있나? 

	_rotation = ToEulerAngles(quat);
	이렇게 world의 로테이션 벡터를 생성하지만
	월드는 이미 조립되어서 자식객체로 전달되기 때문에 의미가 있을까? 

부모의 역행렬을 곱해서 남은 값을 디컴포즈하고 가져오는게 맞더라~ 


오후 1:35 2024-01-31
[fbx리소스 / 빌더 제작]
- 리소스매니저/오브젝트매니저 이름변경

리소스 빌더 제작 완료

사용해보자
완료 -> 잘 됩니다! 

오후 3:23 2024-01-31
[컨트롤러 개선]
1. 컨트롤러가 작동하는지 확인하자

1. 트랜스폼추가
2. 컨트롤러 추가
3. 백그라운드에서 키입력으로 컨트롤러로 트랜스폼의 요소와 월드가 바뀌는지 확인하자


void Controller::TransportPositiveX() 함수가 작동하도록 만들었다.

컨트롤를 사용해보자

오브젝트에서
키 입력하는 곳에
컨트롤러의 함수를 실행하자




fixedUpdate만드세요



오전 10:15 2024-02-01
컨트롤러 컴포넌트를 개선하자 

1. x,y,z를 두고 가산할까? 

이동은 잘 된다

회전을 해볼까? 

일단 회전행렬이 뭘 으미하는가! 
알아야지

Vec3 _rotation;
-> 행렬이 의미하는 것은 각 축의 각도(radian)다


#ifdef _DEBUG
	#ifdef UNICODE
	#pragma comment(linker, "/entry:wWinMainCRTStartup /subsystem:console")
	#else
	#pragma comment(linker, "/entry:WinMainCRTStartup/subsystem:console")
	#endif
#endif
출처: https://playallnight.tistory.com/3 [게임 개발자의 블로그:티스토리]

오후 1:41 2024-02-01
fixed update 만들자


Awake
OnEnable

	Reset

	Start

	FixedUpdate

PhysicsUpdate

	Ontrigger?
	OnCollision??
	Yield WaitForfixedUpdate

OnMouse??

Update

yield null
yield WaitForSeconds
yield www
yield startCorotine



OnApplicationPause

OnApplicationQuit

OnDisable

OnDestroy

fixedUpdate까지 만듦

// 남의 코드를 배껴서 넣어라


오후 6:07 2024-02-01
0. renderer인자전달을 개선하자
1. controller를 개선하자
2. 마우스 이동을 만들자
3. objManager를 개선하자
4. move에서 트랜스폼을 불러와서 포지션을 바꾸는데? 
	-> 오리지날로 갖고 있고? 
	-> 트랜스폼이 갖고 있는 포지션을 

오전 10:13 2024-02-02


엔진 사용법
	1. 오브젝트 만들기
	3. 컴포넌트 만들기
	2. 리소스 만들기
		- 타입
		- 빌더


오후 12:17 2024-02-02
나 뭐했지? 
- 트랜스폼 만듬


fixedupdate 확인
inputmanager 가져오기
timemanager 가져오기
	무엇을 싱글턴으로 만들까? 



Enemy::Enemy()
	: //m_astar(nullptr), 오류 떠서 가려놓음


InputManager	(IManager를 상속받은)
			-> 신경안써도 될지도? 



오후 6:05 2024-02-02
1. 필터정리
2. fsm 관리 어떻게? - 중첩상태를 고려하라
3. objManager를 잘 만들자 (하던것 + ? 만들기)
	1) 오브젝트 생성시에 트랜스폼 붙이기
	2) 트랜스폼을 붙이면서 부모의 트랜스폼을 곱해주기
4. 



/// 
/// 각 스테이트, 이행, 조건
/// 
/// 1스테이트만?, 중첩
/// 
/// 게임 오브젝트를 누가 가지고 있을 것인가?
/// Scene System도 같은 고민을 해야 한다.
/// 

오후 7:48 2024-02-02
1. 오브젝트 매니저
	- 오브젝트매니저가 오브젝트를 생성하고 관리한다
	- scene은 오브젝트매니저를 통해서 오브젝트를 참조 받는다.

2. fsm 관리 어떻게? - 중첩상태를 고려하라
3. objManager를 잘 만들자 (하던것 + ? 만들기)

4. gameobj 기능추가
	1) 오브젝트 생성시에 트랜스폼 붙이기 -> 완료
	2) 트랜스폼을 붙이면서 부모의 트랜스폼을 곱해주기
	3) 원하는 오브젝트를 찾아서 붙일 수 있게 ㄱ 



오해강 - 
1.ObjectManager에 Transform정보를 붙여주고,
	 GameObject 자식으로 GameObject가 들어갈 수 있게 만들 것. - 월요일 전까지
2. Camera 자체를 관리할 수 있게 한다. 카메라라는 컴포넌트를 만들 것. 
	-> 이는 mesh renderer와 비슷하게 Id와 Transform정보로 관리할 것임.

	 일단은 단순 위치 정보와 아이디만 있으면 됨. 카메라의 Id가 있는 이유는 8개까지 만들 수 있는 가능성을 열어둠 - 월요일 전까지
3. PlayerController를 위 만든 것을 바탕으로 FPS라고 부를 수 있는 (ex. 마우스 회전) component를 만들 것    - 화요일


오후 10:37 2024-02-04
현재 부모가 자식을 찾는 방법
	1. id
	2. 이름
		-> 오브젝트 매니저의 벡터를 순회하면서 같은 이름이나 id를 갖고 있는 게임오브젝트에 추가한다.
		-> 게임오브젝트에서 이루어진다. 
		1) 이름을 설정하고 생성을 바로한다.
		2) 이미 생성된 오브젝트에 부모세팅을 한다.

	
layer가 있어야 하는곳
	1) sceneManager
	2) scene

	3) objManager
	4) gameobject

오전 10:54 2024-02-05
리소스의 생성소멸시점을 명확히 하면 좋겠는데

오전 10:54 2024-02-05
inputmanager가져오자
	-> 가져왔습니다

오후 2:23 2024-02-05

마우스로 rotation을 이동시키는! 

이전틱에 움직인 만큼을 저장해서? 


해상도 1920x1080일때

모니터 상에서 
xPosition + width / 2
yPosition + height / 2	값은

클라이언트에서
952 
509 값이다.

클라이언트 값을 그대로 갖고오면


오후 4:04 2024-02-10
왜 카메라와 오브젝트들의 트랜스폼이 반대로 움직일까? 

카메라의 움직임과 이동방향은 정상인데
마우스의 회전이 졸라 이상하다! 

x축회전을 하면 카메라는 제대로 회전하고
오브젝트는 y축 회전을 한다.
그래서 우상향 대각선 방향으로는 카메라와 오브젝트의 회전이 정상이지만 다른때는 그렇지 않다
이거만 되면 진짜 거의 끝나는데!!! 

트랜스폼을 전달하는 곳은 메쉬랜더러와 카메라오브젝트이다
1. 먼저 내가 전달하는 값이 같은지 확인하고
2. 다르다면 그래픽스에서 전달받은 인자를 같은 방식으로 사용하는지 확인해보자

확인 할 것은 x축 회전과 y축 회전이다


오후 10:20 2024-02-10
용준이랑 얘기하면서 할걸; 별것 아닌걸로 고민하고 있었다
회전을 축이 아닌 YawPitchRoll로 부르는 이유를 정확히 알았다.
무대의 상수 하수 같은 것이다.

오후 8:35 2024-02-13
1. 카메라 각도제한
2. 게임매니저 만들기(싱글턴)
3. 오브젝트를 어떻게 가져다 쓸것인가? 
4. 투척 단검 제대로 만들기

오후 7:43 2024-02-12
오후 2:01 2024-02-14
1. 프레임에 따라 마우스감도가 달라진다 
	-> 델타타임으로 바꾸면 마우스가 튄다
	-> 델타타임이 튈때 리턴하는 방식으로 해결


오후 3:50 2024-02-14
문제점과 개선사항을 정리하고 해결하자

0. 플레이어 컨트롤러 회전시 각도제한 필요하다

1. 어떤 아이템이든 다형적으로 잡고 던질 수 있게 만들 것
2. 나이프가 날아가는 방식이 parentworld에 독립적이도록 만들것
3. 

?? 모르겠는데 

오후 5:56 2024-02-14
0. 플레이어 컨트롤러 회전시 각도제한 필요하다
1. 어떤 아이템이든 다형적으로 잡고 던질 수 있게 만들 것

오후 8:11 2024-02-14
1. 이동속도 바뀌는거 해결할 것
2. 아이템 어쩌구 저쩌구 해달란거 아 해줄.. 아진자 걍 해줄것
3. 


멈췃다가 쏘면 잘 가고
그냥 쏘면 잘 안가는 이유는 뭘까? 


오후 2:31 2024-02-15
1. 외부의 카



오후 3:44 2024-02-15
1. 플레이어 y축 각도제한 만들어야함
2. 


오후 4:35 2024-02-15
ui
1. ui 기능은 컴포넌트다
2. ui는 화면상 자신의 위치정보를 갖는다. 
3. update중에 자신이 상호작용 가능한지 체크한다.
4. 트랜스폼으로 그리지 않을까? 
5. 레이어를 둔다

버튼은? '?' 한다.

1. 버튼은 오브젝트안에 컴포넌트로 존재한다.
2. 버튼은 결국 함수를 실행한다
	- 어떤 함수를 실행할지는 람다로 받으면 개꿀
3. 

오후 4:56 2024-02-15
1. object의 active 와 inactive 를 만들어야 할듯
2.  inactive의 경우 자식까지 inactive 되도록 만들어야 한다.

오후 6:07 2024-02-15
어떤 종류의 ui가 필요한가? 

1. 버튼 
만들었음


오전 10:21 2024-02-16
[ui 만들자]
1. 타이머(그래픽스에서 지원해야 함)
	: 화면 중앙에 항상표시, 악마 소환 후 타이머 재설정
2. ITEM UI
	: 현재 갖고 있는 item 을 표시
3. 크로스 헤어
	: 화면 중앙, "물체를 조준했을 경우" 진회색-> 흰색으로변해야함
4. 단검
	:  사용여부에 따른 흑백처리, 쿨타임 동안 게이지 차오름

5. 피격 혈흔
	: hp감소하면 혈흔표시, 화면점점점 좁아짐-> 여러개의 피격혈흔을 만들까? 스프라이트를 바꿀까? 다른 ui가 보여야하니 가장 먼저 그리는 걸로

6. 물체 상호작용
	: 상호작용시 조준점에 원형 게이지 -> 퍼센트를 갖고 있고 보였다 말았다 해야할 것 같은데 그래픽스랑 얘기해봐야 할듯

7. 스테미나
	: 스테미나를 다른 컴포넌트에서 받아오고 퍼센트로 출력 비율을 정해야할듯

8. 아이템 설명
	: 상자에서 아이템을 획득시 아이템 즉시사용, 화면중앙에 팝업
	아이템이름, 효과를 3초동안 표시한다.
	
	회복물약 : 체력이 모두 회복되었습니다.
	염소머리 : 30초 동안 제단의 위치가 표시됩니다.
	역 십자가 : 30초 동안 당신의 이동속도가 2배 증가합니다.
	성수 : 심장 타이머가 10초 감소 합니다.
	십자가 : 30초 동안 당신의 이동속도가 2배 감소합니다.

[만들 수 있는것]

오후 12:24 2024-02-16
타이머 만들었다. 동작확인

uisprite 를 만들어보자
	
sprite는 어떤 기능이 필요한가?
1. 어떤 sprite를 그릴지 갖고 있어야 한다.
2. 그리고 있는 sprite를 변경할 수 있어야 한다.
	(toggle Or switch)
3. 흑백, 반투명이 있으려면 상태변화가 있어야 할 것 같다.


오후 12:54 2024-02-16
조준선색 변경은 없습니다

오후 12:54 2024-02-16
상호작용해서 떴다가 사라지는거 만들어보게

1. 상자를 연다 == 아이템을 획득한다 == 사용
3. 


오후 6:22 2024-02-16


게임시작



게임종료 - 다시 시작, 게임 종료


[hpUI]
-> 플레이어의 hp정보를 받아오면서
시야차단 ui를 만들것
	-> 그럼 캐릭터 obj에 붙어있어도 되나
		-> 이건 좀 아닌것 같다는 생각;
-> 체력 받아오는거 있대 그거 쓰는거로;

[item 사용]
-> tiemchest에서 상호작용할때 받아온다.

awake만들기

오후 7:20 2024-02-17
아이템 상호작용 ? 

[ItemDescUI]
1. 아이템이 상호작용 하는 시점을 알아야한다.
	- 아이템 상호작용 하는 시점에 어떤 아이템인지 알아야한다!
	itemChest를 갖고 있는 놈들을 찾고
	순회
	m_isActivated 가 true일 때 
	m_itemType 을 확인해서 
	itemType에 맞는 설명을 띄워준다.

	m_isInteract가 true일 경우 currentTime과 LoadTime을 받아온다
	
[ItemInteractionUI]
E상호작용은 플레이어컴포넌트를 이용한다.

아이템 상호작용은 아이템 매니저를 받아서써볼까? 
	- 아이템 매니저는 싱글턴을 사용해야 할까? 


오후 2:18 2024-02-18
ui는 윈도우의 해상도를 얻을 수 있어야 할 것 같다

오후 2:18 2024-02-18
아이템 상호작용중 퍼센트를 전달하는 UI를 만들었다.

오후 2:18 2024-02-18
아이템이 사용되었을때 pop up되는 ui를 만들자
오후 4:59 2024-02-18
만들어땅
	// 열린 순간만을 확인하기 위한 bool변수
	bool m_isOpen = false;

	/// 아이템 사용 여부를 확인 하기 위한 get 
	/// 작성자 : 오해강
public:
	bool GetisOpen()const { return m_isOpen; }
	void SetisClose() { m_isOpen = false; }
	ItemList GetItemType() const { return m_itemType; }

오후 5:20 2024-02-18
오해강
dt 해결, UI, 쉬프트 달리기, 시점 제한, 아이템 중 제단 위치 표시

오후 6:46 2024-02-18
해상도 문제를 해결해봅시다
-> 해결

오후 7:45 2024-02-18
XRay 아이템 UI를 만들어 봅시다.

오전 10:45 2024-02-19
무엇을 해야할까 '생각' 해보자

오전 11:14 2024-02-19


마우스 좌표
(900, 520)

오후 12:00 2024-02-19

1. 버튼 업데이트 복붙해
2. 버튼 크기를 설정해
3. set OnClick, OnPressed, OnHover~~~ 를 해
	-> 규칙! 함수는 void 함수명(void) 여야 합니다~ 

참고 : TitleScene.cpp 121번줄


(845,457)

2, 0, 36

오후 5:32 2024-02-19
다시 너무 되는 대로 했다.

오후 8:50 2024-02-19
[xray에 관하여 몇가지는 해야한다.]

1. sprite를 정면을 바라보게 할것(빌보드)
2. 키입력에 따라 콜리전 위치가 이동하지 않도록 할것

오후 8:52 2024-02-19
[Scene을 만들자]

오전 1:55 2024-02-21


오전 10:10 2024-02-20
1. ㄴㅊ둗


오후 4:28 2024-02-20
sprtie 현재 방식

1. 포지션은 left, Top이 맞다
2. size는 sprite와 같은 크기로 입력해주자
size는 현재 (y,x)로 되어있다.



오전 11:37 2024-02-20
introui

1. gameStart
2. help
3. exit




1. 함수안에 들어오는지 먼저 확인한다. (중단점)

2. 그 안에 함수를 넣어주기만 하면 된다




오후 1:52 2024-02-21
커서 보이는것 수정해야함


오전 1:15 2024-02-22
뭘 해야하지? 
1. 버튼과 sprite 일치 시키기
2. 없는 ui 넣기	-> 타이머, 단검, 
3. 없는 기능 만들기 -> 제단띄우기, 커서 보이기
4. 엔딩 만들기


김








오후 4:27 2024-02-21

1. 오브젝트 벡터를 순회한다

2. itemchset 컴포넌트를 갖고 있는 오브젝트를 찾는다

3. itemchest컴포넌트중에 itemtype이 xray인 itemchest컴포넌트를 찾는다.

4. 해당 itemchest컴포넌트를 벡터로 보관한다.

[문제 1]
itemchest를 모아놓은 벡터가 0이다







플레이어의 스테미나를 받아온다

현제/총량 * size.x를 한다.




배경 10

start, exit , help













